[{"title":"Dubbo","url":"/2021/05/05/Dubbo/","content":"","categories":["Dubbo"],"tags":["Dubbo"]},{"title":"Zookeeper","url":"/2021/05/05/Zookeeper/","content":"","categories":["Zookeeper"],"tags":["Zookeeper"]},{"title":"Linux安装Redis","url":"/2021/04/26/Redis/","content":"<h1 id=\"Linux安装单机Redis\"><a href=\"#Linux安装单机Redis\" class=\"headerlink\" title=\"Linux安装单机Redis\"></a>Linux安装单机Redis</h1><h2 id=\"安装gcc\"><a href=\"#安装gcc\" class=\"headerlink\" title=\"安装gcc\"></a>安装gcc</h2><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">yum install gcc</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"进入usr-local文件夹下\"><a href=\"#进入usr-local文件夹下\" class=\"headerlink\" title=\"进入usr/local文件夹下\"></a>进入usr/local文件夹下</h2><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">wget http://download.redis.io/releases/redis-5.0.3.tar.gz</span><br></pre></td></tr></table></figure>\n\n<span id=\"more\"></span>\n\n<h2 id=\"解压到当前文件夹\"><a href=\"#解压到当前文件夹\" class=\"headerlink\" title=\"解压到当前文件夹\"></a>解压到当前文件夹</h2><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">tar xzf redis-5.0.3.tar.gz</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"进入解压后的redis文件夹中然后编译\"><a href=\"#进入解压后的redis文件夹中然后编译\" class=\"headerlink\" title=\"进入解压后的redis文件夹中然后编译\"></a>进入解压后的redis文件夹中然后编译</h2><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> redis-5.0.3</span><br><span class=\"line\">make</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"修改redis的配置文件redis-conf\"><a href=\"#修改redis的配置文件redis-conf\" class=\"headerlink\" title=\"修改redis的配置文件redis.conf\"></a>修改redis的配置文件redis.conf</h2><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">daemonize yes  #后台启动</span><br><span class=\"line\">protected-mode no  #关闭保护模式，开启的话，只有本机才可以访问redis</span><br><span class=\"line\"># 需要注释掉bind</span><br><span class=\"line\">#bind 127.0.0.1（bind绑定的是自己机器网卡的ip，如果有多块网卡可以配多个ip，代表允许客户端通过机器的哪些网卡ip去访问，内网一般可以不配置bind，注释掉即可）</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"启动redis-server\"><a href=\"#启动redis-server\" class=\"headerlink\" title=\"启动redis-server\"></a>启动redis-server</h2><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 启动服务</span></span><br><span class=\"line\">src/redis-server redis.conf</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"验证是否启动成功\"><a href=\"#验证是否启动成功\" class=\"headerlink\" title=\"验证是否启动成功\"></a>验证是否启动成功</h2><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 验证启动是否成功 </span></span><br><span class=\"line\">ps -ef | grep redis </span><br></pre></td></tr></table></figure>\n\n<h2 id=\"启动redis-cli\"><a href=\"#启动redis-cli\" class=\"headerlink\" title=\"启动redis-cli\"></a>启动redis-cli</h2><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 进入redis客户端 </span></span><br><span class=\"line\">src/redis-cli</span><br><span class=\"line\"><span class=\"comment\"># 执行ping</span></span><br><span class=\"line\">127.0.0.1:6379&gt; ping</span><br><span class=\"line\">PONG</span><br><span class=\"line\">127.0.0.1:6379&gt; </span><br></pre></td></tr></table></figure>\n\n<p><font color=\"red\" size=\"5\">以上单机redis安装完成。。。。。</font></p>\n<h1 id=\"Linux安装Redis主从架构\"><a href=\"#Linux安装Redis主从架构\" class=\"headerlink\" title=\"Linux安装Redis主从架构\"></a>Linux安装Redis主从架构</h1><h2 id=\"redis主从架构搭建，配置从节点步骤：\"><a href=\"#redis主从架构搭建，配置从节点步骤：\" class=\"headerlink\" title=\"redis主从架构搭建，配置从节点步骤：\"></a><strong>redis主从架构搭建，配置从节点步骤：</strong></h2><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 在redis目录下创建一个config文件夹然后复制redis.conf</span></span><br><span class=\"line\"><span class=\"comment\"># 修改相关配置</span></span><br><span class=\"line\">port 6380 </span><br><span class=\"line\">pidfile /var/run/redis_6380.pid    <span class=\"comment\"># 把pid进程号写入pidfile配置的文件 </span></span><br><span class=\"line\"><span class=\"comment\"># 需要注释掉bind                             </span></span><br><span class=\"line\"><span class=\"comment\"># bind 127.0.0.1</span></span><br><span class=\"line\"><span class=\"comment\"># 配置主从复制</span></span><br><span class=\"line\">replicaof 192.168.245.130 6379   <span class=\"comment\"># 从本机6379的redis实例复制数据，Redis 5.0之前使用slaveof</span></span><br><span class=\"line\">replica-read-only yes  <span class=\"comment\"># 配置从节点只读</span></span><br><span class=\"line\"><span class=\"comment\"># 启动从节点</span></span><br><span class=\"line\"><span class=\"comment\"># 连接从节点</span></span><br><span class=\"line\">src/redis-cli -p 6380</span><br></pre></td></tr></table></figure>\n\n<p>测试结果</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 在6379实例上写数据</span></span><br><span class=\"line\">127.0.0.1:6379&gt; <span class=\"built_in\">set</span> <span class=\"built_in\">test</span> success</span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 在6380上读数据</span></span><br><span class=\"line\">127.0.0.1:6380&gt; get <span class=\"built_in\">test</span></span><br><span class=\"line\"><span class=\"string\">&quot;success&quot;</span></span><br><span class=\"line\">127.0.0.1:6380&gt; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 在6381上读数据</span></span><br><span class=\"line\">127.0.0.1:6381&gt; get <span class=\"built_in\">test</span></span><br><span class=\"line\"><span class=\"string\">&quot;success&quot;</span></span><br><span class=\"line\">127.0.0.1:6381&gt; </span><br></pre></td></tr></table></figure>\n\n\n\n","categories":["Redis"],"tags":["Redis"]},{"title":"JavaClassLoader","url":"/2021/03/20/JavaClassLoader/","content":"<h1 id=\"类加载运行全过程\"><a href=\"#类加载运行全过程\" class=\"headerlink\" title=\"类加载运行全过程\"></a>类加载运行全过程</h1><p>当使用java命令运行某个类的main函数时，首先需要通过<strong>类加载器</strong>把类加载到<strong>JVM</strong>中</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.fanq.jvm;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.fanq.entity.User;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Math</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> initData = <span class=\"number\">666</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> User user = <span class=\"keyword\">new</span> User();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">compute</span><span class=\"params\">()</span> </span>&#123;  <span class=\"comment\">//一个方法对应一块栈帧内存区域</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> b = <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> c = (a + b) * <span class=\"number\">10</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> c;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Math math = <span class=\"keyword\">new</span> Math();</span><br><span class=\"line\">        math.compute();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<span id=\"more\"></span>\n\n<h2 id=\"通过java执行大体流程如下图\"><a href=\"#通过java执行大体流程如下图\" class=\"headerlink\" title=\"通过java执行大体流程如下图\"></a>通过java执行大体流程如下图</h2><p><img src=\"/2021/03/20/JavaClassLoader/image-20210411133245285.png\" alt=\"image-20210411133245285\"></p>\n<h2 id=\"loadClass的类加载过程\"><a href=\"#loadClass的类加载过程\" class=\"headerlink\" title=\"loadClass的类加载过程\"></a>loadClass的类加载过程</h2><p> <strong>加载-&gt;&gt;验证-&gt;&gt;准备-&gt;&gt;解析-&gt;&gt;初始化-&gt;&gt;使用-&gt;&gt;卸载</strong></p>\n<ul>\n<li>加载：在硬盘上通过IO读入字节码文件，使用类时才会加载类。例如在调用类的main函数，new对象等等。在加载阶段会在内存中生成一个Class对象，作为方法区这个类的各种数据的访问入口(对于程序员来操作类，通过反射)</li>\n<li>验证：检验字节码文件的正确性(java的字节码文件开头有cafe babe)</li>\n<li>准备：给类的静态变量分配内存，并且赋予默认值</li>\n<li>解析：将符号引用替换为直接引用，该阶段会把一些静态方法(也就是符号引用，例如main方法替换为指向数据所存内存的指针或者句柄等[直接引用]，这就是所谓的静态链接过程[类加载期间完成]。动态链接实在程序运行期间完成的，是将符号引用替换为直接引用)</li>\n<li>初始化：对类的静态变量初始化为指定的值，执行静态代码块</li>\n</ul>\n<p><img src=\"/2021/03/20/JavaClassLoader/clipboard-1618120939613.png\" alt=\"img\"></p>\n<p>类被加载到方法区后主要包含 <strong>运行时常量池、类型信息、字段信息、方法信息、类加载器的引用、对应class实例的引用</strong>等信息。</p>\n<p><strong>类加载器的引用</strong>：这个类的类加载器实例的引用</p>\n<p><strong>对应class实例的引用</strong>：类加载器在加载类信息放到方法区后，会创建一个对应类的Class类型的对象实例放到堆中，为了开发人员可以访问方法区中类的信息</p>\n<p><font size=\"3\" color=\"red\">注</font></p>\n<blockquote>\n<p>主类在运行的过程中如果使用到其他类，会逐步的加载这些类。jar和war里面的类不是一次性全部加载的，都是使用的时候才会加载对应的类</p>\n</blockquote>\n<h1 id=\"类加载器和双亲委派机制\"><a href=\"#类加载器和双亲委派机制\" class=\"headerlink\" title=\"类加载器和双亲委派机制\"></a>类加载器和双亲委派机制</h1><h2 id=\"java中的类加载器\"><a href=\"#java中的类加载器\" class=\"headerlink\" title=\"java中的类加载器\"></a>java中的类加载器</h2><p>上面的类加载过程都是通过类加载器来完成的。java中有如下几种类加载器</p>\n<ul>\n<li>引导类加载器：负责加载支撑JVM运行的位于jre的lib目录下的核心类库。例如rt.jar和charsets.jar等</li>\n<li>扩展类加载器：负责加载支撑JVM运行的位于jre的lib目录下的ext扩展目录中的jar。</li>\n<li>应用类加载器：负责加载classpath路径下的类，主要就是加载自己写的那些类</li>\n<li>自定义类加载器：负责加载用户自定义路径下的类</li>\n</ul>\n<p>测试代码如下</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.fanq.jvm;</span><br><span class=\"line\"><span class=\"keyword\">import</span> sun.misc.Launcher;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.net.URL;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestJDKClassLoader</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(String.class.getClassLoader());</span><br><span class=\"line\">        System.out.println(com.sun.crypto.provider.DESKeyFactory.class.getClassLoader().getClass().getName());</span><br><span class=\"line\">        System.out.println(TestJDKClassLoader.class.getClassLoader().getClass().getName());</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println();</span><br><span class=\"line\">        ClassLoader appClassLoader = ClassLoader.getSystemClassLoader();</span><br><span class=\"line\">        ClassLoader extClassloader = appClassLoader.getParent();</span><br><span class=\"line\">        ClassLoader bootstrapLoader = extClassloader.getParent();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;the bootstrapLoader : &quot;</span> + bootstrapLoader);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;the extClassloader : &quot;</span> + extClassloader);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;the appClassLoader : &quot;</span> + appClassLoader);</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;bootstrapLoader加载以下文件：&quot;</span>);</span><br><span class=\"line\">        URL[] urls = Launcher.getBootstrapClassPath().getURLs();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; urls.length; i++) &#123;</span><br><span class=\"line\">            System.out.println(urls[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        System.out.println();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;extClassloader加载以下文件：&quot;</span>);</span><br><span class=\"line\">        System.out.println(System.getProperty(<span class=\"string\">&quot;java.ext.dirs&quot;</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;appClassLoader加载以下文件：&quot;</span>);</span><br><span class=\"line\">        System.out.println(System.getProperty(<span class=\"string\">&quot;java.class.path&quot;</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">运行结果</span><br><span class=\"line\"><span class=\"keyword\">null</span></span><br><span class=\"line\">sun.misc.Launcher$ExtClassLoader</span><br><span class=\"line\">sun.misc.Launcher$AppClassLoader</span><br><span class=\"line\"></span><br><span class=\"line\">the bootstrapLoader : <span class=\"keyword\">null</span></span><br><span class=\"line\">the extClassloader : sun.misc.Launcher$ExtClassLoader@29453f44</span><br><span class=\"line\">the appClassLoader : sun.misc.Launcher$AppClassLoader@18b4aac2</span><br><span class=\"line\"></span><br><span class=\"line\">bootstrapLoader加载以下文件：</span><br><span class=\"line\">file:/C:/Program%20Files/Java/jdk1<span class=\"number\">.8</span><span class=\"number\">.0_181</span>/jre/lib/resources.jar</span><br><span class=\"line\">file:/C:/Program%20Files/Java/jdk1<span class=\"number\">.8</span><span class=\"number\">.0_181</span>/jre/lib/rt.jar</span><br><span class=\"line\">file:/C:/Program%20Files/Java/jdk1<span class=\"number\">.8</span><span class=\"number\">.0_181</span>/jre/lib/sunrsasign.jar</span><br><span class=\"line\">file:/C:/Program%20Files/Java/jdk1<span class=\"number\">.8</span><span class=\"number\">.0_181</span>/jre/lib/jsse.jar</span><br><span class=\"line\">file:/C:/Program%20Files/Java/jdk1<span class=\"number\">.8</span><span class=\"number\">.0_181</span>/jre/lib/jce.jar</span><br><span class=\"line\">file:/C:/Program%20Files/Java/jdk1<span class=\"number\">.8</span><span class=\"number\">.0_181</span>/jre/lib/charsets.jar</span><br><span class=\"line\">file:/C:/Program%20Files/Java/jdk1<span class=\"number\">.8</span><span class=\"number\">.0_181</span>/jre/lib/jfr.jar</span><br><span class=\"line\">file:/C:/Program%20Files/Java/jdk1<span class=\"number\">.8</span><span class=\"number\">.0_181</span>/jre/classes</span><br><span class=\"line\"></span><br><span class=\"line\">extClassloader加载以下文件：</span><br><span class=\"line\">C:\\Program Files\\Java\\jdk1<span class=\"number\">.8</span><span class=\"number\">.0_181</span>\\jre\\lib\\ext;C:\\WINDOWS\\Sun\\Java\\lib\\ext</span><br><span class=\"line\"></span><br><span class=\"line\">appClassLoader加载以下文件：</span><br><span class=\"line\">C:\\Program Files\\Java\\jdk1<span class=\"number\">.8</span><span class=\"number\">.0_181</span>\\jre\\lib\\charsets.jar;C:\\Program Files\\Java\\jdk1<span class=\"number\">.8</span><span class=\"number\">.0_181</span>\\jre\\lib\\deploy.jar;C:\\Program Files\\Java\\jdk1<span class=\"number\">.8</span><span class=\"number\">.0_181</span>\\jre\\lib\\ext\\access-bridge-<span class=\"number\">64.</span>jar;C:\\Program Files\\Java\\jdk1<span class=\"number\">.8</span><span class=\"number\">.0_181</span>\\jre\\lib\\ext\\cldrdata.jar;C:\\Program Files\\Java\\jdk1<span class=\"number\">.8</span><span class=\"number\">.0_181</span>\\jre\\lib\\ext\\dnsns.jar;C:\\Program Files\\Java\\jdk1<span class=\"number\">.8</span><span class=\"number\">.0_181</span>\\jre\\lib\\ext\\jaccess.jar;C:\\Program Files\\Java\\jdk1<span class=\"number\">.8</span><span class=\"number\">.0_181</span>\\jre\\lib\\ext\\jfxrt.jar;C:\\Program Files\\Java\\jdk1<span class=\"number\">.8</span><span class=\"number\">.0_181</span>\\jre\\lib\\ext\\localedata.jar;C:\\Program Files\\Java\\jdk1<span class=\"number\">.8</span><span class=\"number\">.0_181</span>\\jre\\lib\\ext\\nashorn.jar;C:\\Program Files\\Java\\jdk1<span class=\"number\">.8</span><span class=\"number\">.0_181</span>\\jre\\lib\\ext\\sunec.jar;C:\\Program Files\\Java\\jdk1<span class=\"number\">.8</span><span class=\"number\">.0_181</span>\\jre\\lib\\ext\\sunjce_provider.jar;C:\\Program Files\\Java\\jdk1<span class=\"number\">.8</span><span class=\"number\">.0_181</span>\\jre\\lib\\ext\\sunmscapi.jar;C:\\Program Files\\Java\\jdk1<span class=\"number\">.8</span><span class=\"number\">.0_181</span>\\jre\\lib\\ext\\sunpkcs11.jar;C:\\Program Files\\Java\\jdk1<span class=\"number\">.8</span><span class=\"number\">.0_181</span>\\jre\\lib\\ext\\zipfs.jar;C:\\Program Files\\Java\\jdk1<span class=\"number\">.8</span><span class=\"number\">.0_181</span>\\jre\\lib\\javaws.jar;C:\\Program Files\\Java\\jdk1<span class=\"number\">.8</span><span class=\"number\">.0_181</span>\\jre\\lib\\jce.jar;C:\\Program Files\\Java\\jdk1<span class=\"number\">.8</span><span class=\"number\">.0_181</span>\\jre\\lib\\jfr.jar;C:\\Program Files\\Java\\jdk1<span class=\"number\">.8</span><span class=\"number\">.0_181</span>\\jre\\lib\\jfxswt.jar;C:\\Program Files\\Java\\jdk1<span class=\"number\">.8</span><span class=\"number\">.0_181</span>\\jre\\lib\\jsse.jar;C:\\Program Files\\Java\\jdk1<span class=\"number\">.8</span><span class=\"number\">.0_181</span>\\jre\\lib\\management-agent.jar;C:\\Program Files\\Java\\jdk1<span class=\"number\">.8</span><span class=\"number\">.0_181</span>\\jre\\lib\\plugin.jar;C:\\Program Files\\Java\\jdk1<span class=\"number\">.8</span><span class=\"number\">.0_181</span>\\jre\\lib\\resources.jar;C:\\Program Files\\Java\\jdk1<span class=\"number\">.8</span><span class=\"number\">.0_181</span>\\jre\\lib\\rt.jar;G:\\demo\\demo\\target\\classes;G:\\develop\\Maven\\repository\\org\\openjdk\\jol\\jol-core\\<span class=\"number\">0.9</span>\\jol-core-<span class=\"number\">0.9</span>.jar;G:\\develop\\IntelliJ IDEA <span class=\"number\">2020.3</span><span class=\"number\">.3</span>\\lib\\idea_rt.jar</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"类加载器初始化过程\"><a href=\"#类加载器初始化过程\" class=\"headerlink\" title=\"类加载器初始化过程\"></a>类加载器初始化过程</h2><p>参见类加载全过程流程图可知，会创建JVM启动器实例sun.misc.Launcher。</p>\n<p>在Launcher类中构造方法内部，创建了两个类加载器，分别是sun.misc.Launcher.ExtClassLoader(扩展类加载器)和sun.misc.Launcher.AppClassLoader(应用类加载器)。</p>\n<p>JVM默认使用Launcher的getClassLoader()方法返回的类加载器AppClassLoader的实例加载我们的应用程序。</p>\n<p>jdk源码如下</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Launcher</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">       Launcher.ExtClassLoader var1;</span><br><span class=\"line\">       <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">           <span class=\"comment\">//构造扩展类加载器。在构造得过程中将其父类加载器属性设置为null</span></span><br><span class=\"line\">           var1 = Launcher.ExtClassLoader.getExtClassLoader();</span><br><span class=\"line\">       &#125; <span class=\"keyword\">catch</span> (IOException var10) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> InternalError(<span class=\"string\">&quot;Could not create extension class loader&quot;</span>, var10);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">           <span class=\"comment\">//构造应用类加载器。在构造的过程中将其父类加载器属性设置为ExtClassLoader</span></span><br><span class=\"line\">           <span class=\"comment\">//Launcher的loader属性值是AppClassLoader，我们都是使用这个类加载器来加载我们自己下的类</span></span><br><span class=\"line\">           <span class=\"keyword\">this</span>.loader = Launcher.AppClassLoader.getAppClassLoader(var1);</span><br><span class=\"line\">       &#125; <span class=\"keyword\">catch</span> (IOException var9) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> InternalError(<span class=\"string\">&quot;Could not create application class loader&quot;</span>, var9);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       Thread.currentThread().setContextClassLoader(<span class=\"keyword\">this</span>.loader);</span><br><span class=\"line\">       String var2 = System.getProperty(<span class=\"string\">&quot;java.security.manager&quot;</span>);</span><br><span class=\"line\">       。。。。。。。其他代码</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"双亲委派机制\"><a href=\"#双亲委派机制\" class=\"headerlink\" title=\"双亲委派机制\"></a>双亲委派机制</h2><p>JVM类加载器是有父子层级结构关系的，如下图</p>\n<p><img src=\"/2021/03/20/JavaClassLoader/clipboard-1618123296065.png\" alt=\"img\"></p>\n<p>类的加载其实就是一个双亲委派机制，加载某个类的时候会先请求父类加载器去寻找加载目标，找不到在继续委托上层父类加载器加载，如果父类加载器在自己加载的路径下找到目标类，就加载目标类，反之如果所有的父类加载器都在自己加载的路径下找不到目标类，那么就会向下退回加载请求，那么扩展类加载器就会自己加载，如果扩展类加载器找不到就会继续回退到应用类加载器加载。。。</p>\n<p><font size=\"3\" color=\"red\">通俗的说就是</font></p>\n<blockquote>\n<p>双亲委派机制就是有类加载就先找父类，父类不行，就再由自己加载</p>\n</blockquote>\n<h2 id=\"源码体现\"><a href=\"#源码体现\" class=\"headerlink\" title=\"源码体现\"></a>源码体现</h2><p>应用程序类加载器AppClassLoader加载器的双亲委派机制源码，最终实在父类ClassLoader中的loadClass方法，里面实现了双亲委派机制，大体逻辑如下</p>\n<ul>\n<li>首先检查一下当前类是否被加载过，加载过了就直接返回。</li>\n<li>如果类没有被加载过，那么先判断有没有父类加载器，有就委托给父类加载器，没有父类就指定为引导类加载器(bootstrap)来加载。</li>\n<li>如果父类或者bootstrap类加载器都没有加载到目标类，那么就调用当前类加载器中的findClass方法来完成加载(ClassLoader中的findClass为空实现，目地就是为了子类来实现具体的加载方式)</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">protected</span> Class&lt;?&gt; loadClass(String name, <span class=\"keyword\">boolean</span> resolve)</span><br><span class=\"line\">        <span class=\"keyword\">throws</span> ClassNotFoundException</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// First, check if the class has already been loaded</span></span><br><span class=\"line\">            <span class=\"comment\">// 先检查有没有被加载过</span></span><br><span class=\"line\">            Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (c == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">long</span> t0 = System.nanoTime();</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 再检查有没有父类加载器</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (parent != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// 有父类就委托父类加载器加载</span></span><br><span class=\"line\">                        c = parent.loadClass(name, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// 没有父类加载器就使用bootstrap引导类加载器加载</span></span><br><span class=\"line\">                        c = findBootstrapClassOrNull(name);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (ClassNotFoundException e) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// ClassNotFoundException thrown if class not found</span></span><br><span class=\"line\">                    <span class=\"comment\">// from the non-null parent class loader</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 如果父类和bootstrap类加载器都没有加载到</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (c == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// If still not found, then invoke findClass in order</span></span><br><span class=\"line\">                    <span class=\"comment\">// to find the class.</span></span><br><span class=\"line\">                    <span class=\"keyword\">long</span> t1 = System.nanoTime();</span><br><span class=\"line\">                    <span class=\"comment\">// 调用当前类加载器的findClass方法。ClassLoader中的findClass是空实现，所以会调用当前子类中的findClass实现</span></span><br><span class=\"line\">                    c = findClass(name);</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"comment\">// this is the defining class loader; record the stats</span></span><br><span class=\"line\">                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class=\"line\">                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class=\"line\">                    sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 不会执行</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (resolve) &#123;</span><br><span class=\"line\">                resolveClass(c);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> c;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"为什么要设计双亲委派机制？\"><a href=\"#为什么要设计双亲委派机制？\" class=\"headerlink\" title=\"为什么要设计双亲委派机制？\"></a>为什么要设计双亲委派机制？</h2><ul>\n<li>沙箱安全机制：自己写的java.lang.String类不会被加载，这样可以防止java中的核心类库不会被随意的篡改</li>\n<li>避免类的重复加载：当父类已经加载了该类时，子类加载器就没有必要在加载一次了。保证了类只会被加载一次。</li>\n</ul>\n<p>代码验证</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> java.lang;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">String</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;**************My String Class**************&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">运行结果</span><br><span class=\"line\">错误: 在类 java.lang.String 中找不到 main 方法, 请将 main 方法定义为:</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span></span><br><span class=\"line\"><span class=\"function\">否则 JavaFX 应用程序类必须扩展javafx.application.Application</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>全盘负责委托机制</strong></p>\n<p>全盘负责是指当一个类加载器加载一个类的时候，除非显示的使用另一个类加载器，不然改类所依赖的及其引用的类也有这个类加载来加载。</p>\n<h1 id=\"自定义类加载器\"><a href=\"#自定义类加载器\" class=\"headerlink\" title=\"自定义类加载器\"></a>自定义类加载器</h1><p>上面提到<strong>ClassLoader</strong>中的<strong>loadClass</strong>方法实现了双亲委派，还有一个<strong>findClass</strong>空实现。这是自定义类加载器的两个核心方法。所以我们要继承ClassLoader，然后重写findClass方法</p>\n<h2 id=\"实现双亲委派机制\"><a href=\"#实现双亲委派机制\" class=\"headerlink\" title=\"实现双亲委派机制\"></a>实现双亲委派机制</h2><p>代码如下</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.fanq;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.FileInputStream;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.Method;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyClassLoaderTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyClassLoader</span> <span class=\"keyword\">extends</span> <span class=\"title\">ClassLoader</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> String classPath;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MyClassLoader</span><span class=\"params\">(String classPath)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.classPath = classPath;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">byte</span>[] loadByte(String name) <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">            name = name.replaceAll(<span class=\"string\">&quot;\\\\.&quot;</span>, <span class=\"string\">&quot;/&quot;</span>);</span><br><span class=\"line\">            FileInputStream fis = <span class=\"keyword\">new</span> FileInputStream(classPath + <span class=\"string\">&quot;/&quot;</span> + name</span><br><span class=\"line\">                    + <span class=\"string\">&quot;.class&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">int</span> len = fis.available();</span><br><span class=\"line\">            <span class=\"keyword\">byte</span>[] data = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[len];</span><br><span class=\"line\">            fis.read(data);</span><br><span class=\"line\">            fis.close();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> data;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">protected</span> Class&lt;?&gt; findClass(String name) <span class=\"keyword\">throws</span> ClassNotFoundException &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">byte</span>[] data = loadByte(name);</span><br><span class=\"line\">                <span class=\"comment\">//defineClass将一个字节数组转为Class对象，这个字节数组是class文件读取后最终的字节数组。</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> defineClass(name, data, <span class=\"number\">0</span>, data.length);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ClassNotFoundException();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String args[])</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//初始化自定义类加载器，过程中会把自定义类加载器的父加载器设置为应用程序类加载器AppClassLoader</span></span><br><span class=\"line\">        MyClassLoader classLoader = <span class=\"keyword\">new</span> MyClassLoader(<span class=\"string\">&quot;G:/test&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">//G盘创建 test/com/fanq/jvm 几级目录，将一个类的class文件放在目录下</span></span><br><span class=\"line\">        Class clazz = classLoader.loadClass(<span class=\"string\">&quot;com.fanq.jvm.User1&quot;</span>);</span><br><span class=\"line\">        Object obj = clazz.newInstance();</span><br><span class=\"line\">        <span class=\"comment\">//通过反射来调用print方法</span></span><br><span class=\"line\">        Method method = clazz.getDeclaredMethod(<span class=\"string\">&quot;print&quot;</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        method.invoke(obj, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        System.out.println(clazz.getClassLoader().getClass().getName());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">运行结果</span><br><span class=\"line\">================自定义类加载器=================</span><br><span class=\"line\">com.fanq.MyClassLoaderTest$MyClassLoader</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"打破双亲委派机制\"><a href=\"#打破双亲委派机制\" class=\"headerlink\" title=\"打破双亲委派机制\"></a>打破双亲委派机制</h2><p>打破双亲委派机制就是要重新ClassLoader中的loadClass方法</p>\n<p>代码如下</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyClassLoaderTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyClassLoader</span> <span class=\"keyword\">extends</span> <span class=\"title\">ClassLoader</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> String classPath;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MyClassLoader</span><span class=\"params\">(String classPath)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.classPath = classPath;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">byte</span>[] loadByte(String name) <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">            name = name.replaceAll(<span class=\"string\">&quot;\\\\.&quot;</span>, <span class=\"string\">&quot;/&quot;</span>);</span><br><span class=\"line\">            FileInputStream fis = <span class=\"keyword\">new</span> FileInputStream(classPath + <span class=\"string\">&quot;/&quot;</span> + name</span><br><span class=\"line\">                    + <span class=\"string\">&quot;.class&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">int</span> len = fis.available();</span><br><span class=\"line\">            <span class=\"keyword\">byte</span>[] data = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[len];</span><br><span class=\"line\">            fis.read(data);</span><br><span class=\"line\">            fis.close();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> data;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * 重写类加载方法，实现自己的加载逻辑，不委派给双亲加载</span></span><br><span class=\"line\"><span class=\"comment\">         * <span class=\"doctag\">@param</span> name 包名</span></span><br><span class=\"line\"><span class=\"comment\">         * <span class=\"doctag\">@param</span> resolve</span></span><br><span class=\"line\"><span class=\"comment\">         * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">         * <span class=\"doctag\">@throws</span> ClassNotFoundException</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        <span class=\"keyword\">protected</span> Class&lt;?&gt; loadClass(String name, <span class=\"keyword\">boolean</span> resolve)</span><br><span class=\"line\">                <span class=\"keyword\">throws</span> ClassNotFoundException &#123;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// First, check if the class has already been loaded</span></span><br><span class=\"line\">                Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (c == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// If still not found, then invoke findClass in order</span></span><br><span class=\"line\">                    <span class=\"comment\">// to find the class.</span></span><br><span class=\"line\">                    <span class=\"keyword\">long</span> t1 = System.nanoTime();</span><br><span class=\"line\">                    <span class=\"comment\">//打破双亲委派机制,自定义的包名走自定义的类加载器</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (!name.startsWith(<span class=\"string\">&quot;com.fanq.jvm&quot;</span>))&#123;</span><br><span class=\"line\">                        c = <span class=\"keyword\">this</span>.getParent().loadClass(name);</span><br><span class=\"line\">                    &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        c = findClass(name);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"comment\">// this is the defining class loader; record the stats</span></span><br><span class=\"line\">                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class=\"line\">                    sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (resolve) &#123;</span><br><span class=\"line\">                    resolveClass(c);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> c;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">protected</span> Class&lt;?&gt; findClass(String name) <span class=\"keyword\">throws</span> ClassNotFoundException &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">byte</span>[] data = loadByte(name);</span><br><span class=\"line\">                <span class=\"comment\">//defineClass将一个字节数组转为Class对象，这个字节数组是class文件读取后最终的字节数组。</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> defineClass(name, data, <span class=\"number\">0</span>, data.length);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ClassNotFoundException();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String args[])</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//初始化自定义类加载器，过程中会把自定义类加载器的父加载器设置为应用程序类加载器AppClassLoader</span></span><br><span class=\"line\">        MyClassLoader classLoader = <span class=\"keyword\">new</span> MyClassLoader(<span class=\"string\">&quot;G:/test&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">//G盘创建 test/com/fanq/jvm 几级目录，将一个类的class文件放在目录下</span></span><br><span class=\"line\">        Class clazz = classLoader.loadClass(<span class=\"string\">&quot;com.fanq.jvm.User1&quot;</span>);</span><br><span class=\"line\">        Object obj = clazz.newInstance();</span><br><span class=\"line\">        <span class=\"comment\">//通过反射来调用print方法</span></span><br><span class=\"line\">        Method method = clazz.getDeclaredMethod(<span class=\"string\">&quot;print&quot;</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        method.invoke(obj, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        System.out.println(clazz.getClassLoader().getClass().getName());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">运行结果</span><br><span class=\"line\">================自定义类加载器=================</span><br><span class=\"line\">com.fanq.MyClassLoaderTest$MyClassLoader</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"可以使用自定义加载器加载java-lang-String么\"><a href=\"#可以使用自定义加载器加载java-lang-String么\" class=\"headerlink\" title=\"可以使用自定义加载器加载java.lang.String么\"></a>可以使用自定义加载器加载java.lang.String么</h2><p>不可以，因为类加载器最终都会调用defineClass方法，defineClass方法中有preDefineClass方法校验。ClassLoader中的preDefineClass方法源码如下</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> ProtectionDomain <span class=\"title\">preDefineClass</span><span class=\"params\">(String name,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                        ProtectionDomain pd)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!checkName(name))</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NoClassDefFoundError(<span class=\"string\">&quot;IllegalName: &quot;</span> + name);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Note:  Checking logic in java.lang.invoke.MemberName.checkForTypeAlias</span></span><br><span class=\"line\">    <span class=\"comment\">// relies on the fact that spoofing is impossible if a class has a name</span></span><br><span class=\"line\">    <span class=\"comment\">// of the form &quot;java.*&quot;</span></span><br><span class=\"line\">    <span class=\"comment\">//以java.开头的包名都不可以被加载</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((name != <span class=\"keyword\">null</span>) &amp;&amp; name.startsWith(<span class=\"string\">&quot;java.&quot;</span>)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> SecurityException</span><br><span class=\"line\">            (<span class=\"string\">&quot;Prohibited package name: &quot;</span> +</span><br><span class=\"line\">             name.substring(<span class=\"number\">0</span>, name.lastIndexOf(<span class=\"string\">&#x27;.&#x27;</span>)));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pd == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        pd = defaultDomain;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (name != <span class=\"keyword\">null</span>) checkCerts(name, pd.getCodeSource());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> pd;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>补充：Hotspot源码JVM启动执行main方法流程</strong></p>\n<p><img src=\"/2021/03/20/JavaClassLoader/hotspot%E6%BA%90%E7%A0%81jvm%E5%90%AF%E5%8A%A8%E6%89%A7%E8%A1%8Cmain%E6%96%B9%E6%B3%95%E6%B5%81%E7%A8%8B.jpg\" alt=\"img\"></p>\n<p>以上所有资料来源于网络，如有侵权，请联系我删除。</p>\n<p>文章中的JDK是1.8版本，如有错误欢迎大家指正，如转载请注明出处！！！</p>\n","categories":["Java"],"tags":["Java"]}]